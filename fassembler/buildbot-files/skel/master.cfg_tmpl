# -*- mode: python ;-*-
from buildbot.changes.pb import PBChangeSource
from buildbot.changes.svnpoller import SVNPoller
from buildbot.process import factory
from buildbot.steps.shell import ShellCommand
from buildbot.steps.source import SVN
from buildbot.status import html, mail, words
from buildbot import scheduler
from buildbot.buildslave import BuildSlave
from twisted.python import log

import os
import subprocess

"""Buildbot master configuration for opencore and related software.

{{config.editwarning}}
"""


BASEPORT=int('{{config.child_baseport}}')  # Used for the fassembler builds
OCBASEDIR='{{config.oc_basedir}}'

# All the ports we care about... hacky
allports = range(BASEPORT, BASEPORT + 11)  # for the trunk build.
allports.extend(range(BASEPORT + 100, BASEPORT + 111))  # for the nyc build.

slavenames = ['slave1']
slaves = [BuildSlave(name, '{{config.buildbot_passwd}}') for name in slavenames]

c = BuildmasterConfig = {}
# "The BuildmasterConfig name is the only one which matters: all other
# names defined during the execution of this file are discarded."
# (from http://buildbot.net/repos/release/docs/buildbot.html#Configuration)
				   
c['projectName'] = 'OpenCore'
c['projectURL']  = 'http://www.openplans.org/projects/opencore'
c['buildbotURL'] = '{{config.buildbot_url}}'

c['slavePortnum'] = int('{{config.buildslave_port}}')


# Buildbot only allows tracking ONE change source for the entire
# buildmaster config.  Rats. So if we want to track multiple source
# trees, I think we need multiple buildmasters with different configs.
# (I talked to Brian W. at PyCon and he confirmed this.)
#
# As a hackaround for now, we'll watch our entire repository but use a
# split_file callback that ignores large parts of the tree.  This
# means we get only the changes we care about - BUT then both the
# sputnik and opencore builders see all those changes, even though the
# 'sputnik' stuff is not relevant to the opencore builder. So the
# opencore builder will fire a build every time you change stuff in
# sputnik, and you'll be on the blamelist.  I think this is similar to
# what buildbot.zope.org does.
def split_file(path):
    pieces = path.split('/')
    if pieces[0] not in ('opencore', 'sputnik', 'fassembler',
                         'oc-tt', 'oc-js', 'oc-cab',
                         'topp.featurelets', 'topp.utils',
                         'CabochonClient',
                         ):
        log.msg("ignoring file %s, not relevant?" % path)
        return None   # Ignore this file.
    elif pieces[1] == 'trunk':
        branch = pieces[1]
        filepath = '/'.join(pieces[2:])
        return (branch, filepath)
    elif pieces[1] == 'branches':
        branch = pieces[2]
        filepath = '/'.join(pieces[3:])
        return (branch, filepath)
    else:
        log.msg("ignoring file %s, maybe a tag?" % path)
        return None

c['change_source'] = [
    SVNPoller(svnurl='https://svn.openplans.org/svn/',
              pollinterval=180,
              split_file=split_file,
              )
]

# Build slaves that are allowed to attach.
c['slaves'] = slaves


#########################################################################
# FACTORIES - these configure how to build stuff.
#########################################################################

class ToppShellCommand(ShellCommand):

    def __init__(self, *args, **kw):
        # Force colorization off in fassembler child processes.
        # Do that by forcing these env vars blank.
        # (actually it's cmdutils, used by fassembler, that checks these).
        # But on principle, we still allow the user to override this.
        kw.setdefault('env', {})
        kw['env'].setdefault('LSCOLORS', '')
        kw['env'].setdefault('LS_COLORS', '')
        kw['env'].setdefault('COLORTERM', '')
        kw['env'].setdefault('CLICOLOR', '')
        ShellCommand.__init__(self, *args, **kw)
    
    # Print something not so stupid as "shell_9" when there are
    # problems.  It was pretty time-consuming to figure out where
    # in buildbot this happens.
    def getText2(self, cmd, results):
        # XXX maybe report a failure count?
        # see comments in buildbot/process/buildstep.py around line 1004.
        return self.describe(done=True)

    @property
    def descriptionDone(self):
        # Writing out two separate descriptions is too much work.
        return self.description



def make_factory(name, baseport=BASEPORT, requirements_repo=None,
                 zopectl_suites=['opencore'],
                 ftestsdir=None, flunc_suite='all',
                 fassembler_targets=[]):
    """
    We have multiple very similar builds that just use different
    requirements_svn_repo. Hence, this factory function.
    """
    fac = factory.BuildFactory()
    fac.name = name
    
    # Accept certificates (for svn).
    # XXX is there an easier way to find the right bin directory?
    fac.addStep(ToppShellCommand,
                command='{{os.path.join("..", "..", "bin", "accept_certificates.sh")}}',
                description=['accept svn certs',],
                )

    # Clean up after previous runs.
    fac.addStep(ToppShellCommand, command="rm -rf %s *bz2 *gz *zip" % OCBASEDIR,
                description='remove old files',
                )

    # Bootstrap the topp build tools (fassembler).
    fac.addStep(ToppShellCommand,
                command='svn export https://svn.openplans.org/svn/fassembler/trunk/fassembler-boot.py',   # string instead of list causes it to be run via sh.
                description=['get fassembler', 'bootstrap script'],
                haltOnFailure=1)

    fac.addStep(ToppShellCommand,
                command=['python', 'fassembler-boot.py', 'oc'],
                description='bootstrap fassembler',
                haltOnFailure=1)

    # Run the build.
    buildcmd = ['%s/bin/fassembler' % OCBASEDIR,
                '--no-interactive',
                'var=%s/var' % OCBASEDIR,
                'base_port=%d' % baseport,]
    if requirements_repo:
        buildcmd.append('requirements_svn_repo=%s' % requirements_repo)
    if ftestsdir:
        buildcmd.append('ftests_path=%s' % ftestsdir)
    fac.addStep(ToppShellCommand,
                command=buildcmd + fassembler_targets,
                description=['build', name, 'and dependencies'],
                haltOnFailure=1)

    # Create the zope unit test wrapper script.
    # XXX maybe this should move into fassembler:opencore
    # ... or just fix the upstream zopectl bug, namely that zopectl
    # always exits 0 even when tests fail.
    fac.addStep(ToppShellCommand,
                command='{{os.path.join("..", "..", "bin", "mkzopetest.sh")}}',
                description=['create zopectl', 'test wrapper script'],
                haltOnFailure=True
                )

    # Run the zopectl unit tests.
    for suite in zopectl_suites:
        fac.addStep(ToppShellCommand, 
                    command=['%s/opencore/zope/bin/zopetest' % OCBASEDIR, '-s',
                             suite],
                    description=['run', suite, 'unit tests'],
                    haltOnFailure=False)


    # Run the flunc tests. Wait a bit for services to come up.
    fac.addStep(ToppShellCommand, 
                command='%s/bin/supervisord && sleep 5' % OCBASEDIR,
                description=['start services', 'for functional tests'],
                haltOnFailure=1)

    fac.addStep(ToppShellCommand, 
                command=['%s/opencore/bin/flunc' % OCBASEDIR,
                         '-p', '%s/%s' % (OCBASEDIR, ftestsdir),
                         '-t', 'http://localhost:%d' % baseport,
                         flunc_suite],
                description='run flunc tests',
                haltOnFailure=0)

    # Shut down subprocesses; wait a bit in case they take a while to die.
    fac.addStep(ToppShellCommand,
                command='%s/bin/supervisorctl shutdown && sleep 20' % OCBASEDIR,
                description='shut down',
                haltOnFailure=1)

    # No really, you guys need to die. bug #2230.
    # For some reason, portkill seems to always exit 1, so ignore "failures".
    fac.addStep(ToppShellCommand,
                command=['{{os.path.join("..", "..", "bin", "portkill")}}',
                         ] + [str(port) for port in allports],
                description=['kill any running', 'instances using', 'the ports'],
                haltOnFailure=False)
    return fac


oc_factory = make_factory(
    'Openplans (partial stack)', baseport=BASEPORT,
    ftestsdir='opencore/src/opencore/ftests/',
    fassembler_targets=[
        'fassembler:topp',
        'fassembler:supervisor',
        'fassembler:opencore',
        'fassembler:deliverance',
        'fassembler:cabochon',
        'fassembler:twirlip',
        'fassembler:zeo',
        ],
    flunc_suite='all',
    zopectl_suites=['opencore', 'Products.listen', 'Products.wicked'],
    )


nycsr_factory = make_factory(
    'Livable Streets (partial stack)',
    requirements_repo='https://svn.openplans.org/svn/build/requirements/livablestreets/trunk/',
    baseport=BASEPORT + 100, #XXX hacky way to avoid port overlap.
    ftestsdir='opencore/src/sputnik/ftests/',
    fassembler_targets=[
        'fassembler:topp',
        'fassembler:supervisor',
        'fassembler:opencore',
        'fassembler:deliverance',
        'fassembler:zeo',
        ],
    flunc_suite='minimal',
    zopectl_suites=['opencore'],
    )

    
############################################################################
# BUILDERS - each tells a slave which build factory to use.
############################################################################

opencore_builders = [
    {'name': 'opencore-minimal',
     'slavename': name,
     'builddir': 'oc',
     'factory': oc_factory}
    for name in slavenames]

nycstreets_builders = [
    {'name': 'nycstreets-minimal',
     'slavename': name,
     'builddir': 'nycstreets',
     'factory': nycsr_factory}
    for name in slavenames]

c['builders'] = opencore_builders + nycstreets_builders

###########################################################################
# SCHEDULERS - control when the master decides to fire off a build.
###########################################################################

buildOnChange = scheduler.Scheduler(
    'Post Commit Build', 
    branch='trunk',
    treeStableTimer=5*60, 
    builderNames=[b['name'] for b in c['builders']]
    )

buildOpencoreNightly  = scheduler.Nightly(
    'Opencore Nightly Build', 
    builderNames=[b['name'] for b in opencore_builders],
    hour=3, minute=0)

buildNycstreetsNightly  = scheduler.Nightly(
    'Sputnik Nightly Build', 
    builderNames=[b['name'] for b in nycstreets_builders],
    hour=3, minute=30)


c['schedulers'] = [buildOnChange, buildOpencoreNightly, buildNycstreetsNightly]



############################################################################
# STATUS NOTIFICATION
############################################################################


# This is the status display that should be presented to the Universe, 
# hence forcing builds to begin is disabled. 
publicWebStatus = html.WebStatus(http_port='{{config.buildmaster_public_port}}', allowForce=False)

# This is the status display that should be presented to developers 
# only, allowing them to manually force builds, stop builds etc. 
developerWebStatus = html.WebStatus(http_port='{{config.buildmaster_private_port}}', allowForce=True)


# Mails only to the status list.
listMailer = mail.MailNotifier(
    fromaddr='buildbot@openplans.org',
    mode='failing',  # People got annoyed by all the successes.
    subject='%(builder)s FAILURE',
    relayhost='mail.openplans.org',
    lookup='openplans.org',
    sendToInterestedUsers=False,
    extraRecipients=['opencore-builds@lists.openplans.org'],
    )


# Notify by email anyone who has made changes to a build that
# breaks.
breakMailer = mail.MailNotifier(
    fromaddr='buildbot@openplans.org', 
    mode='failing',
    subject='%(builder)s FAILURE, and sadly, you are on the blamelist',
    relayhost='mail.openplans.org', 
    lookup='openplans.org',
    sendToInterestedUsers=True,
    )

# An IRC status bot. Is there a way to get this to always announce
# failures?
ircbot = words.IRC(host='irc.freenode.net',
                   nick='buildbot-topp',
                   channels=['#openplans'],
                   allowForce=False,
                   )


c['status'] = [developerWebStatus,
               breakMailer,
               listMailer,
               ircbot,
               ]


############################################################################
# write the configuration to a file for debugging.
# XXX first monkeypatch buildslave so it doesn't blow up on repr.
def repr_buildslave(s):
    return '<BuildSlave(%r)' % s.slavename
BuildSlave.__repr__ = repr_buildslave

import pprint
outfile = file('config.out', 'w')
outfile.write(pprint.pformat(c))
outfile.close()
